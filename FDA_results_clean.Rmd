---
title: "FDA Analysis on Percolation Point - Stories wPLI Random"
output: html_document
knit: (function(inputFile, encoding) {rmarkdown::render(inputFile, encoding=encoding, output_file='/Users/willi3by/Desktop/FDA_stories_wPLI_rand.html')})
---

# Introduction

This notebook goes over the necessary steps to perform Functional Data Analysis on the function of node density by percolation point across subjects of various ages.
These data were generated by (details of MEG connectivity here....).

### Initial setup
```{r setup, results=FALSE, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(fda)
library(ggplot2)
library(ggrepel)
library(reshape2)
library(RColorBrewer)
library(pracma)
library(plotly)
library(R.matlab)
library(gridExtra)
library(parallel)
```


### Functions.
```{r fns_for_smoothing, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
#Function to get GCV values per lambda and plot for all at once. 
plot_gcv_by_lambda <- function(lambda_range, evalrange, data_mat, basis_obj, derivative){
  all_gcvs <- vector(mode="numeric", length=length(lambda_range))
  for(l in 1:length(lambda_range)){
    fdPar_obj <- fdPar(basis_obj, derivative, exp(lambda_range[l]))
    all_gcvs[l] <- sum(smooth.basis(evalrange, data_mat, fdPar_obj)$gcv)
  }
  plot(lambda_range, all_gcvs, type='l')
  return(all_gcvs)
}
# Function to smooth a single subject.
plot_gcv_by_lambda_single_subject <- function(lambda_range, evalrange, data_mat, basis_obj, derivative, data_idx, plot=FALSE){
  all_gcvs <- vector(mode="numeric", length=length(lambda_range))
  for(l in 1:length(lambda_range)){
    fdPar_obj <- fdPar(basis_obj, derivative, exp(lambda_range[l]))
    all_gcvs[l] <- smooth.basis(evalrange, data_mat[,data_idx], fdPar_obj)$gcv
  }
  if(plot==TRUE){
  plot(lambda_range, all_gcvs, type='l')
  }
  return(all_gcvs)
}
#Function to smooth all individuals.
smooth_individuals <- function(lambda_range, evalrange, data_mat, basis_obj, derivative){
  nsubjs <- ncol(data_mat)
  all_fds <- vector("list", length=nsubjs)
  all_dfs <- vector("list", length=nsubjs)
  for(s in 1:nsubjs){
  all_gcvs <- plot_gcv_by_lambda_single_subject(lambda_range =  lambda_range, evalrange = evalrange, 
                               data_mat = data_mat, basis_obj = basis_obj, derivative = derivative, data_idx = s)
  lambda_min_gcv <- lambda_range[which.min(all_gcvs)]
  percfdPar <- fdPar(perc_basis, 2, exp(lambda_min_gcv))
  perc_smooth <- smooth.basis(evalrange, data_mat[,s], percfdPar)
  percfd <- perc_smooth$fd
  all_fds[[s]] <- percfd
  all_dfs[[s]] <- perc_smooth$df
  }
  return(list(all_fds, all_dfs))
}
#Function to "rebuild" fd for further analyses after smoothing individuals. 
build_fd <- function(all_fds){
  mat_rows <- nrow(all_fds[[1]]$coefs)
  mat_cols <- length(all_fds)
  fd_mat <- matrix(0, nrow=mat_rows, ncol=mat_cols)
  for(i in 1:length(all_fds)){
    fd_mat[,i] <- all_fds[[i]]$coefs
  }
  fd <- all_fds[[1]]
  fd$coefs <- fd_mat
  return(fd)
}

par_ssecv <- function(lambda, betalisti, which_beta, coefsfd, xlist){
  betalisti[[which_beta]]$lambda <- exp(lambda)
  CVi <- fRegress.CV(coefsfd, xlist, betalisti)
  return(CVi$SSE.CV)
}
```

### Load data and trim.
```{r import_data}
func_data <- readMat('/Users/willi3by/Desktop/FDA_Perc_Point_Project/FDA_Perc_Results_20210928/FDA_data_batch_1[34]/stories_wpli_perc_point_FDA_randi.mat')
func_data <- func_data$perc.point.FDA
func_mat <- do.call(rbind, func_data)
func_mat <- do.call(rbind, func_mat)
func_df <- as.data.frame(func_mat)
func_df_trimmed <- func_df[,c(280:400)] #Trim because 100%-30% density seems unstable
func_df_melted <- melt(t(func_df_trimmed))
```

### Plot original data.
```{r plot_orig_data}
g <- ggplot(data = func_df_melted) + geom_line(aes(x=Var1, y=value, group=Var2, color=as.factor(Var2))) +
  theme_classic() + theme(legend.position = "none")
g
```


### Set parameters for FDA Analysis. 
- #### fdnames: names of dimensions in functional data object, list of domain (time, density, space, etc.), replications (subjects), and value (i.e., Perc point)
- #### perc_mat: trimmed dataframe from above, in matrix format Num_Density_Points x Subjects
- #### densities: vector of density points, should be same length as n_rows of perc_mat
- #### norder: order of polynomial at each knot of the B-spline
- #### nbasis: number of basis functions, determined by Num_Density_Points+norder-2 (subtracting 2 accomodates for first and last spline, where fit is least stable)
```{r setup_fda_analysis}
fdnames <- list("Density", "Subject", "Percolation Point")
perc_mat <- as.matrix(t(func_df_trimmed))
densities <- c(280:400) #30% to 0% since inverse
norder <- 4
nbasis <- length(densities)+norder-2 #-2 for end splines
nsubjs <- 82
```

```{r create_basis_and_smooth}
perc_basis <- create.bspline.basis(c(280,400), nbasis, norder, densities)
lambda_range = seq(from=-5, to=15, length=20) #Exponential range to cover as much ground as possible.
all_fds_and_dfs <- smooth_individuals(lambda_range = lambda_range, evalrange = densities,
                              data_mat = perc_mat, basis_obj = perc_basis, derivative = 2)
percfd <- build_fd(all_fds_and_dfs[[1]])
plot(percfd)
```

### Assess goodness of fit by looking at variance of residuals. Steps are:
1. Generate predicted values.
2. Calculate residuals (actual-predicted)
3. Calculate variance by subject.
4. Calculate variance by density point.
5. Create standard deviation (by density point) curve and smooth.
6. Evaluate standard deviation fit to get plot of standard deviation over density. 
7. Remove outliers and refit fd.

```{r plot_residuals}
pred_percmat <- eval.fd(densities, percfd) #Get predicted functions from fd fit
percres <- perc_mat - pred_percmat #Calculate residuals (actual - predicted)
percvar1 <- apply(percres^2, 1, sum)/ncol(perc_mat) #Sum of squared residuals by subject divided by number of replicates 
percvar2 <- apply(percres^2, 2, sum)/(nrow(perc_mat) - unlist(all_fds_and_dfs[[2]])) #Sum of squared residuals by density point, divided by density points minus degrees of freedom to fit each curve
plot(percvar1, type='l', xlab="Density", ylab="Log(Standard Deviation)", main="Standard Deviation by Density")
plot(percvar2, xlab="Subjects", ylab="Standard Deviation", main="Standard Deviation by Subject")
#At this point check for outliers and remove from initial analysis. 
percvar2_scaled <- scale(percvar2)
outliers <- which(abs(percvar2_scaled) > 2)
print(paste(outliers, "is an outlier"))
#Now refit fd.
perc_mat <- perc_mat[,-c(outliers)]
lambda_range = seq(from=-5, to=15, length=20) #Exponential range to cover as much ground as possible.
all_fds_and_dfs <- smooth_individuals(lambda_range = lambda_range, evalrange = densities,
                              data_mat = perc_mat, basis_obj = perc_basis, derivative = 2)
percfd <- build_fd(all_fds_and_dfs[[1]])
plot(percfd)
```

### Perform initial regression and plot unsmoothed betas.
```{r plot_initial_betas}
agelist <- vector("list", length=2)
ages <- readMat('/Users/willi3by/Desktop/FDA_Perc_Point_Project/FDA_Perc_Results_20210924/FDA_data_batch_1[34]/ages.mat')
sex <- readMat('/Users/willi3by/Desktop/FDA_Perc_Point_Project/FDA_Perc_Results_20210924/FDA_data_batch_1[34]/sex.mat')
ages <- ages$ages[-outliers]
sex <- sex$sex[-outliers]
coefs <- percfd$coefs
coefsfd <- fd(coefs, perc_basis, percfd$fdnames)
xlist <- list(rep(1,ncol(perc_mat)), c(ages), c(sex))
betalist <- vector("list", length = 2)
betafdPar <- fdPar(perc_basis, 2)
betalist[[1]] <- betafdPar
betalist[[2]] <- betafdPar
betalist[[3]] <- betafdPar
fRegressList <- fRegress(coefsfd, xlist, betalist)
betaestlist <- fRegressList$betaestlist
plot(betaestlist[[1]])
plot(betaestlist[[2]])
plot(betaestlist[[3]])
```

### Smooth betas and reperform regression. 
```{r plot_smoothed_betas}
betalist <- vector("list", length = 2)
loglam  <- seq(-5,12,length=10)
betalisti <- betaestlist
no_cores <- detectCores()
cl <- makeCluster(no_cores)
clusterEvalQ(cl, {library(fda)})
sse.cv1 <- parLapply(cl, loglam, par_ssecv, betalisti, which_beta=1, coefsfd=coefsfd, xlist=xlist)
sse.cv2 <- parLapply(cl, loglam, par_ssecv, betalisti, which_beta=2, coefsfd=coefsfd, xlist=xlist)
sse.cv3 <- parLapply(cl, loglam, par_ssecv, betalisti, which_beta=3, coefsfd=coefsfd, xlist=xlist)
opt_lambda_1 <- 10^unlist(loglam)[which.min(unlist(sse.cv1))]
opt_lambda_2 <- 10^unlist(loglam)[which.min(unlist(sse.cv2))]
opt_lambda_3 <- 10^unlist(loglam)[which.min(unlist(sse.cv3))]
betafdPar1 <- fdPar(perc_basis, 2, opt_lambda_1)
betafdPar2 <- fdPar(perc_basis, 2, opt_lambda_2)
betafdPar3 <- fdPar(perc_basis, 2, opt_lambda_3)
betalist[[1]] <- betafdPar1
betalist[[2]] <- betafdPar2
betalist[[3]] <- betafdPar3
fRegressList <- fRegress(coefsfd, xlist, betalist)
betaestlist <- fRegressList$betaestlist
betaestlist[[1]]$fd$fdnames <- list("Density", "Intercept", "Betas")
betaestlist[[2]]$fd$fdnames <- list("Density", "Effect of Age", "Betas")
betaestlist[[3]]$fd$fdnames <- list("Density", "Effect of Sex", "Betas")
plot(betaestlist[[1]])
plot(betaestlist[[2]])
plot(betaestlist[[3]])
```

### Calculate confidence intervals. 
```{r plot_betas_with_conf_int}
density_fine <- seq(from=280, to=400, length=1000)
# Sample smooth to get y2cmap.
perc_smooth <- smooth.basis(densities, perc_mat, fdPar(perc_basis, 2, 1))
betaestlist <- fRegressList$betaestlist
perc.hatfd <- fRegressList$yhatfdobj
perc.hat.mat <- eval.fd(densities, perc.hatfd)
resmat <- perc_mat - perc.hat.mat
SigmaE <- cov(t(resmat))
perc_fine_mat <- eval.fd(density_fine, percfd)
percmeanvec <- eval.fd(density_fine, mean.fd(percfd))
perc.hat.finemat <- eval.fd(density_fine, perc.hatfd)
resmat <- perc_fine_mat - perc.hat.finemat
resmat0 <- perc_fine_mat - percmeanvec %*% matrix(1,1,ncol(perc_mat))
SSE0 <- apply((resmat0)^2, 1, sum)
SSE1 <- apply(resmat^2, 1, sum)
Rsqr <- (SSE0-SSE1)/SSE0
y2cMap <- perc_smooth$y2cMap
stderrlist <- fRegress.stderr(fRegressList, y2cMap, SigmaE)
betastderrlist <- stderrlist$betastderrlist
titlelist <- list("Intercept", "Age")
plotbeta(betaestlist, betastderrlist, density_fine, titlelist)
```

### Hypothesis Testing. 
```{r plot_f_stat_with_significance}
F.res <- Fperm.fd(coefsfd, xlist, betalist, nperm=200, plotres = T)
```
